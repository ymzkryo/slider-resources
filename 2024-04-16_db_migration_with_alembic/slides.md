---
theme: seriph
background: https://source.unsplash.com/collection/94734566/1920x1080
class: text-center
highlighter: shiki
info: |
  ## 2024-04-16_db_migration_with_alembic
  Presentation slides for 2024-04-16_db_migration_with_alembic.
transition: slide-left
title: 2024-04-16_db_migration_with_alembic
mdc: true
githubPages:
  ogp: true

---

# alembic によるデータベース管理とMigration

<!-- このページでは、Alembicを使ったデータベース管理とマイグレーションの概要を紹介します。Alembicとは何か、そしてなぜデータベース管理に有効なのかを説明し、その基本的な概念を明らかにします。具体的な使用例を挙げながら、このツールの強力な機能を示すことが目的です。 -->

---

# 講義のアジェンダ

- FastAPIでのデータベース操作
- マイグレーションのベストプラクティス
- アンチパターンの例
- Q&A

---

# FastAPIでのデータベース操作

- SQLAlchemyの紹介
- ORMとは何か？

<!-- このセクションでは、FastAPIを用いたデータベース操作に焦点を当て、特にSQLAlchemyとORM（Object Relational Mapping）について詳しく説明します。SQLAlchemyはPythonで最も広く使われているデータベースツールキットの一つで、データベースとのやり取りを抽象化し、Pythonオブジェクトを通じてデータベース操作を可能にします。ORMについては、それがどのようにしてデータベースのテーブルとPythonのクラスをマッピングするのか、そしてそれがなぜ開発者にとって便利なのかを解説します。FastAPIとこれらのツールを組み合わせることで、効率的かつ強力なウェブアプリケーションを構築することができます。具体的なコード例を交えて、これらの概念を実践的に理解していただくことを目指します。 -->

---

# SQLAlchemyの概要

SQLAlchemyは、PythonのORM（Object-Relational Mapping）フレームワークである。データベースとオブジェクト指向プログラミング言語間の橋渡しを行い、SQLクエリの代わりにPythonコードを使ってデータベース操作を可能にする。

<!-- このスライドでは、SQLAlchemyが何であり、なぜ多くのPython開発者に選ばれているのかについて解説します。ORMの概念と、SQLAlchemyが提供する抽象化レイヤがどのように開発の効率を向上させるかを説明します。 -->

---

# SQLAlchemyの基本的な使用方法

SQLAlchemyを使用すると、データベーステーブルはPythonクラスとして定義され、レコードはそのクラスのインスタンスとして表される。これにより、データベース操作をオブジェクト指向のアプローチで行えるようになる。

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

engine = create_engine('sqlite:///example.db')
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

new_user = User(name='John Doe')
session.add(new_user)
session.commit()
```

<!-- このスライドでは、SQLAlchemyを使った簡単なデータベース操作の例を示します。テーブルの定義からレコードの追加までのプロセスを通じて、SQLAlchemyの基本的な使用方法を解説します。 -->

---

# SQLAlchemyの高度な機能

SQLAlchemyは、リレーションシップの定義、複雑なクエリの構築、継承を用いたデータモデルの拡張といった高度なデータモデリング機能を提供する。これらの機能により、開発者は複雑なビジネスロジックを簡潔にコード化でき、大規模なアプリケーション開発においても柔軟性と効率性を実現できる。

---

## リレーションシップの定義

リレーションシップを定義することで、テーブル間の関連を表現し、オブジェクト間の関係性をコード上で直感的に扱うことが可能となる。この機能は、複数のテーブルにまたがるデータの取り扱いを簡素化し、データ整合性を保ちながら効率的な開発を支援する。


```python
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'))

    user = relationship("User", back_populates="addresses")

User.addresses = relationship("Address", order_by=Address.id, back_populates="user")
```
<!-- このスライドでは、SQLAlchemyの高度な機能に焦点を当てます。リレーションシップの管理を用いたデータモデルの拡張が、複雑なデータ構造を効果的に扱うための強力なツールであることを解説します。これらの機能を活用することで、よりリッチなデータ表現が可能になり、開発プロセスが効率化されます。 -->

---

## 継承の利用

SQLAlchemyでは、継承を利用して、共通の属性を持つモデル間でコードの重複を避けることができる。これにより、異なるテーブルを持つが関連するエンティティをモデル化する際に、基底クラスを定義し、その派生クラスとして具体的なサブクラスを作成することが可能となる。継承の利用は、データモデルの拡張性とメンテナンス性を向上させる。


```python
class Employee(User):
    __tablename__ = 'employees'
    id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    hire_date = Column(Date)

    __mapper_args__ = {
        'polymorphic_identity':'employee',
    }

```

<!-- このスライドでは、SQLAlchemyの高度な機能に焦点を当てます。継承を用いたデータモデルの拡張が、複雑なデータ構造を効果的に扱うための強力なツールであることを解説します。これらの機能を活用することで、よりリッチなデータ表現が可能になり、開発プロセスが効率化されます。 -->

---

# ORMの基本概念

ORM（Object-Relational Mapping）は、リレーショナルデータベースのテーブルとオブジェクト指向プログラミング言語のクラスとの間のマッピングを実現する技術である。この技術により、開発者はデータベースを直接操作するSQLを書くことなく、プログラミング言語のクラスを使用してデータベースの操作が可能になる。

<!-- ORMの導入により、開発者はデータベース操作をより直感的に行えるようになります。このスライドでは、ORMの概念とその利点について説明します。特に、データモデルをコードとして表現することの重要性と、開発プロセスにおける効率化に焦点を当てます。 -->

---

# ORMの利点と課題

ORMは、プログラミングの抽象化レベルを高め、データベース操作の効率化を実現する。具体的な利点としては、開発速度の向上、コードの再利用性の向上、データベース設計とビジネスロジックの分離が挙げられる。一方で、パフォーマンスのオーバーヘッドや複雑なクエリの難易度上昇など、課題も存在する。

<!-- ORMを使用することで得られる主な利点と、遭遇する可能性のある課題について解説します。特に、ORMを適切に活用することで、これらの課題をどのように克服できるかについても触れます。このスライドを通じて、ORMの採用を検討する際の考慮点を提供します。 -->

---

# データベース操作ORM使用 - サンプル
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    email = Column(String)

Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

new_user = User(name='John Doe', email='john.doe@example.com')
session.add(new_user)
session.commit()

user = session.query(User).filter_by(name='John Doe').first()
print(f'Added user: {user.name}, Email: {user.email}')

```
<!-- 
このコードサンプルでは、SQLAlchemyというORMライブラリを使用しています。
ORMを使用する主な利点は、データベース操作をオブジェクト指向のアプローチで行えることです。

この例では、まずデータベースへの接続を設定し、次にユーザーモデルを定義しています。このモデルは、データベースのテーブルに対応しており、
テーブルの各行はこのクラスのインスタンスとして扱われます。SQLAlchemyを使うことで、
SQLクエリを直接書くことなくデータベーステーブルの作成、データの追加、データのクエリなどが可能になります。

特に、新しいユーザーの追加はPythonのオブジェクトを作成してセッションに追加するだけで完了し、
コミットすることでデータベースに反映されます。最後に、追加したユーザーをクエリしてその情報を表示しています。

このアプローチにより、データベース操作の抽象化レベルが高まり、
開発者はデータモデルとビジネスロジックに集中できるようになります。
-->

---

# データベース操作ORM未使用 - サンプル
```python
import sqlite3

conn = sqlite3.connect('example.db')
c = conn.cursor()

c.execute('''
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    email TEXT
)
''')

c.execute('INSERT INTO users (name, email) VALUES (?, ?)', ('John Doe', 'john.doe@example.com'))

conn.commit()

c.execute('SELECT * FROM users WHERE name=?', ('John Doe',))
user = c.fetchone()
print(f'Added user: {user[1]}, Email: {user[2]}')

conn.close()

```
<!-- 
このコードサンプルでは、Python標準のsqlite3ライブラリを使用して、ORMなしでデータベース操作を行っています。
ORMを使用しない場合、データベース操作には直接SQLクエリを書く必要があります。

この例では、まずデータベースへの接続を開き、ユーザーテーブルが存在しない場合は作成します。
次に、新しいユーザーをINSERTクエリを使用してテーブルに追加し、コミットして変更を保存しています。

ユーザーの追加後、SELECTクエリを使って追加したユーザーの情報をクエリし、表示しています。
最後に、使用が完了したデータベース接続を閉じています。

ORMを使用しないこの方法では、データベースとのやり取りを細かくコントロールできる一方で、
SQLクエリの記述によるエラーのリスクや、SQLインジェクションといったセキュリティリスクを自分で管理する必要があります。
また、コードの可読性や保守性にも影響を与える可能性があります。
-->

---

# FastAPIにおけるデータベース接続

FastAPIでデータベース接続を管理するための`database.py`ファイルでは、データベースとの接続設定やセッション管理が行われる。主にSQLAlchemyを利用してORM (Object-Relational Mapping) の設定を行う。

---

# FastAPIにおけるデータベース接続 - MySQL編

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# 接続情報を定数として定義
DATABASE_USERNAME = 'user'
DATABASE_PASSWORD = 'password'
DATABASE_HOST = 'localhost'
DATABASE_NAME = 'mydatabase'

SQLALCHEMY_DATABASE_URL = f"mysql+mysqlconnector://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}/{DATABASE_NAME}"

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

```

---

# FastAPIにおけるデータベース接続 - MySQL編(解説)

## 接続情報の定数定義

```python
# 接続情報を定数として定義
DATABASE_USERNAME = 'user'
DATABASE_PASSWORD = 'password'
DATABASE_HOST = 'localhost'
DATABASE_NAME = 'mydatabase'

SQLALCHEMY_DATABASE_URL = f"mysql+mysqlconnector://{DATABASE_USERNAME}:{DATABASE_PASSWORD}@{DATABASE_HOST}/{DATABASE_NAME}"
```

<!--最初に、データベースの接続情報（ユーザー名、パスワード、ホスト名、データベース名）を定数として定義しています。これにより、コードの他の部分でこれらの値を直接使用する代わりに、定数を参照することができます。このアプローチは、コードの変更や管理を簡単にし、誤りを防ぐ効果があります。-->

---

# FastAPIにおけるデータベース接続 - MySQL編(解説)

## SQLAlchemyのエンジン作成

```python
engine = create_engine(SQLALCHEMY_DATABASE_URL)
```

<!-- 
このコード行では、`create_engine`関数を使用して、指定されたデータベース接続URL（`SQLALCHEMY_DATABASE_URL`）に基づき、データベースとの接続を管理するエンジンを作成しています。このエンジンはSQLAlchemyの中心的な機能であり、SQLクエリの実行、セッションの生成、トランザクションの管理など、データベースとの全ての交信を担います。データベース接続URLはデータベースの種類、ユーザー名、パスワード、ホスト名、データベース名など、接続に必要な情報を含んでおり、これにより特定のデータベースインスタンスへの接続が可能になります。`create_engine`に渡されるオプションは、データベースの種類や使用するドライバによって異なる場合がありますが、一般的には接続プールの設定やエンコーディング、タイムアウトなど、データベース接続の振る舞いをカスタマイズするために使用されます。
-->

---

# FastAPIにおけるデータベース接続 - MySQL編(解説)

## セッションファクトリの作成

```python
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

```

<!-- 
`sessionmaker`関数は、データベースセッションを作成するためのファクトリを生成します。セッションは、データベースとのやり取りを行う際に使用されるオブジェクトで、トランザクションの管理やデータベース操作の実行に使用されます。`autocommit=False`と`autoflush=False`の設定により、セッションの振る舞いが制御され、より細かいトランザクション管理を可能にします。セッションを使うことで、操作を一連のトランザクションとしてグループ化し、必要に応じてコミットまたはロールバックを行うことができます。`bind=engine`によってこのセッションファクトリは特定のデータベースエンジンに紐づけられ、セッションを通じてそのデータベースとのやりとりが可能になります。このセットアップにより、アプリケーションコード内でデータベース操作をより柔軟に扱うことができるようになります。
-->

---

# FastAPIにおけるデータベース接続 - MySQL編(解説)

## ベースクラスの定義

```python
Base = declarative_base()
```

<!-- 
`declarative_base`関数は、SQLAlchemy ORMで使用されるモデルクラスのベースクラスを生成します。このベースクラスを継承して作成されたモデルクラスは、データベースのテーブルと対応付けられ、ORMを介してデータベース操作をより簡単に行うことができます。具体的には、このベースクラスを使用してモデルを定義することで、テーブルのカラムをクラスの属性として定義し、SQLAlchemyが提供する豊富な機能を利用してデータベースとのやり取りを行うことが可能になります。このアプローチにより、データモデルとデータベーススキーマの定義がPythonコード内で直接行え、データベース操作の抽象化と自動化が実現します。
-->

---

# マイグレーションのベストプラクティス

- 分割してマイグレーションを行う
- 本番環境への適用前のテスト
- バージョン管理の活用
- 逆向きのマイグレーションの作成


---

# 分割してマイグレーションを行う

大きな変更を一度に適用するのではなく、可能な限り小さな単位に分割してマイグレーションを行います。このアプローチにより、各変更の影響範囲が限定され、問題が発生した際の特定と修正が容易になります。

<!-- 分割してマイグレーションを行うことのメリットには、変更の管理がしやすくなること、問題発生時に迅速に対応できることなどがあります。このアプローチは、特に大きなプロジェクトや複数人での開発において有効です。 -->

---

## 分割してマイグレーションを行う - サンプル(テーブルの追加)

```python
"""Add user table

Revision ID: 01
Revises:
Create Date: 2022-09-01 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '01'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.create_table('user',
    sa.Column('id', sa.Integer, primary_key=True),
    sa.Column('name', sa.String(50), nullable=False),
    sa.Column('email', sa.String(120), unique=True, nullable=False)
    )

def downgrade():
    op.drop_table('user')

```
<!-- 
このスライドでは、大きなデータベース変更を小さなステップに分割して実行する方法について説明します。示されたマイグレーションファイルは、新しい`user`テーブルを追加するためのものです。

マイグレーションをこのように分割する主な利点は、変更の適用と問題発生時の追跡が容易になることです。また、必要に応じて特定の変更だけを簡単にロールバックできる柔軟性も提供します。このアプローチは、開発プロセスの透明性を高め、チームメンバー間でのコミュニケーションを促進します。
-->

---

## マイグレーションを分割して行う - サンプル(カラムの追加)

```python
"""Add age column to user table

Revision ID: 02
Revises: 01
Create Date: 2022-09-02 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '02'
down_revision = '01'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('user', sa.Column('age', sa.Integer, nullable=True))

def downgrade():
    op.drop_column('user', 'age')

```

<!--
このスライドでは、既存のテーブルに新しいカラムを追加するマイグレーションのサンプルを示しています。分割してマイグレーションを行うアプローチの一環として、`user`テーブルに`age`カラムを追加する小さな変更を独立したマイグレーションとして実装しています。

マイグレーションをこのように細かく管理することで、変更の粒度を細かくし、開発プロセスをよりコントロールしやすくします。また、問題が発生した際に、影響を受ける部分だけを特定しやすくなり、迅速な対応が可能になります。

このアプローチは、大規模なデータベース更新作業をより安全かつ効率的に行うための重要な手法です。  
-->

---

## マイグレーションを分割して行う - サンプル(nullableの変更)

既存のカラムで`NULL`が許容されているが、これを許容しないように変更したい場合、直接カラムの`nullable`属性を変更するだけではマイグレーションが失敗します。これは、既存データに`NULL`値が存在する場合、制約違反が発生するためです。

### デフォルト値で既存の`NULL`データを更新

```python
from alembic import op
import sqlalchemy as sa

def upgrade():
    # userテーブルのemailカラムにNULLが存在する場合、デフォルト値で更新
    op.execute("UPDATE user SET email = 'default@example.com' WHERE email IS NULL")
    op.alter_column('user', 'email', existing_type=sa.String(length=120), nullable=False)

```

<!--
このスライドでは、`nullable`属性の変更時に既存データが`NULL`を含む場合の対処法について説明しています。まず、対象カラムの既存の`NULL`データを適切なデフォルト値で更新し、その後でカラムの`nullable`属性を`False`に変更します。このプロセスを通じて、マイグレーションの際のエラーを避けることができます。
-->

---

# 本番環境への適用前のテスト

本番環境にマイグレーションを適用する前に、徹底的なテストを行うことは非常に重要です。これには、開発環境やステージング環境でのテストが含まれ、予期しないエラーやデータ損失を防ぐために必要なステップです。

## テストプロセス

1. **開発環境でのテスト**: 新しいマイグレーションが予定通りに機能するかを検証します。
2. **ステージング環境でのテスト**: 本番環境に近い条件でマイグレーションを実行し、さらに詳細なテストを行います。
3. **データ整合性の確認**: マイグレーション後のデータが正しく、完全であることを確認します。
4. **パフォーマンステスト**: マイグレーションがシステムのパフォーマンスに与える影響を評価します。

<!-- 
このスライドでは、本番環境への適用前に必要なテストプロセスについて説明しています。開発環境とステージング環境での徹底的なテストを通じて、本番環境でのマイグレーションがスムーズに行われるように準備します。特に、ステージング環境でのテストは本番環境と同様の条件を再現することで、リスクを最小限に抑えることができます。
-->

---

## 開発環境でのテスト
- マイグレーションの適用:   
開発環境に新しいマイグレーションを適用し、エラーが発生しないことを確認する。  
- 機能テスト:  
アプリケーションの関連機能がマイグレーション後も正常に動作するかテストする。  
例えば、新しいテーブルにデータが挿入できるか、既存のデータに対して期待通りのクエリが実行できるかなど。  

---

## ステージング環境でのテスト
- 本番環境との条件整合:  
ステージング環境で本番環境に近いデータと設定を用いてマイグレーションを適用し、予期しない挙動がないか確認する。  
- ロードテストとパフォーマンス評価:  
大量のデータやリクエストを処理する際のパフォーマンスをテストし、マイグレーションがシステムのパフォーマンスに悪影響を及ぼさないことを確認する。  
- セキュリティチェック:  
マイグレーションによって新たに導入された変更がセキュリティ上の脆弱性を生じさせていないか検証する。  

---

## データ整合性の確認
- データ検証:  
マイグレーション後のデータが完全であり、かつ整合性が保たれていることを確認する。  
これには、マイグレーション前後でのデータの照合、予期せぬデータ損失がないかのチェックが含まれる。  
- バックアップとリカバリプロセスの確認:  
データのバックアップが正しく行われているか、そして必要に応じてリカバリが可能であることを確認する。  

<!-- 
このスライドでは、本番環境への適用前に必要なテストプロセスについて詳細に説明しています。開発環境での初期テストからスタートし、ステージング環境での包括的なテストを経て、データの整合性とシステムの安定性を最終確認します。この徹底的なテストを通じて、マイグレーションが予期せぬ問題を引き起こすリスクを最小限に抑えることができます。
-->

---

## パフォーマンステスト
本番環境への適用前のテストプロセスにおいて、パフォーマンステストは特に重要になる。  
このテストは、マイグレーション後のシステムが高いトラフィックや大量のデータを効率的に処理できることを確認するために実施される。  


## パフォーマンステストのステップ
- ロードテスト:  
システムが大量のリクエストを同時に処理できるかをテストする。
- ストレステスト:  
システムの限界を把握するため、通常の運用負荷を超えるリクエストを送信する。
- スケーラビリティテスト:  
システムが成長するデータ量やユーザー数に応じて適切にスケールアップできるかを確認する。

<!--
このスライドでは、本番環境にマイグレーションを適用する前に行うべきパフォーマンステストの重要性と、具体的なテスト手法について説明しています。マイグレーションがシステムのパフォーマンスに悪影響を及ぼさないようにするため、ロードテスト、ストレステスト、スケーラビリティテストを含む徹底的なパフォーマンス評価が必要です。これにより、本番環境でのユーザー体験が最適化されることを保証します。
-->

---

# バージョン管理の活用

マイグレーションプロセスにおけるバージョン管理システムの活用は、変更の追跡、共有及び協調作業を容易にし、マイグレーションの整合性を保つ。これにより、複数の開発者間の作業が効率化される。

## バージョン管理の利点
- **変更履歴の追跡**: どの変更がいつ、誰によって行われたかが明確になる。
- **差分の確認**: 異なるバージョン間の変更内容を簡単に確認できる。
- **ロールバックの容易化**: 問題が発生した場合、以前の安定した状態へ簡単に戻せる。

<!-- 
このスライドでは、マイグレーションにおけるバージョン管理システムの重要性と、それを活用することの利点について解説しています。バージョン管理を適切に活用することで、開発プロセスが透明になり、チームメンバー間のコミュニケーションが促進されます。特に、複数人での開発や大規模プロジェクトにおいて、バージョン管理の活用は非常に重要です。プロジェクトの進行状況を正確に追跡し、必要に応じて以前の安定したバージョンに戻すことができるため、リスクを最小限に抑えることができます。
-->

---

## バージョン管理で気を付けるべきこと

マイグレーションファイルの管理において、バージョン管理は変更の追跡、共有、及び協調作業を容易にする。特にマイグレーションファイルの命名規則や管理には以下のポイントに注意する必要がある。

<!--
マイグレーションファイルをバージョン管理する際には、一意性を保つ命名規則を設けること、変更内容が分かるようにすること、そして逆マイグレーションが可能であることが重要です。これらのポイントに注意を払うことで、マイグレーションプロセスがスムーズに進行し、開発チーム間でのコミュニケーションも促進されます。特に、大規模なプロジェクトや複数人での開発において、これらの実践はプロジェクトの成功に不可欠です。
-->

---

## マイグレーションファイルの命名規則
- **一意性を保つ**
- **日付やタイムスタンプを利用する**
- **変更内容を簡潔に記述する**

<!--
一意性を保つ: マイグレーションファイルの名前は、プロジェクト内で一意である必要があります。これにより、どのマイグレーションが適用されているか、または適用されていないかを容易に識別できます。  
日付やタイムスタンプを利用する: マイグレーションファイルの名前に日付やタイムスタンプを含めることで、マイグレーションが作成された順序を明確にできます。例えば、20210401_add_user_tableのようにします。  
変更内容を簡潔に記述する: ファイル名からマイグレーションの主な目的や変更内容がわかるようにすると、ファイルを探す時間が節約でき、理解もしやすくなります。  
-->

---

## マイグレーションファイルの管理
- **逆マイグレーションの準備**
- **詳細なコメントを追加する**

<!--
逆マイグレーションの準備: すべてのマイグレーションファイルには、変更をロールバックするための逆マイグレーションコードを含めるべきです。これにより、問題が発生した場合に以前の状態に戻せるようになります。  
詳細なコメントを追加する: マイグレーションファイル内には、変更の目的や背景、特定の変更が必要とされた理由についてのコメントを追加すると良いでしょう。これにより、他の開発者がマイグレーションの意図を理解しやすくなります。  
-->

---

## チーム内での共有とコミュニケーション
- **マイグレーション戦略を共有する**
- **マイグレーション適用の順序を確認する**

<!--
マイグレーション戦略を共有する: 新しいマイグレーションを追加する際は、チーム内でその内容と目的を共有し、フィードバックを受けることが重要です。これにより、予期しない問題を未然に防げる場合があります。  
マイグレーション適用の順序を確認する: 複数の開発者が異なるマイグレーションを同時に進めている場合、それらが互いに依存しないように注意し、適用の順序を正しく管理する必要があります。  
-->

---

# 逆向きのマイグレーションの作成

マイグレーションを実装する際には、進行方向だけでなく、必要に応じて変更を元に戻せるように、逆向きのマイグレーションも準備することが重要である。これにより、新たなマイグレーションが予期せぬ問題を引き起こした場合でも、システムを安定した状態に戻すことができる。

## 逆向きマイグレーションの利点
- **安全性の向上**: 新しい変更による問題からシステムを守り、迅速に元の状態に戻すことができる。
- **リスク管理**: マイグレーションによる影響をテストしやすくなり、本番環境でのリスクを最小限に抑えることができる。
- **柔軟性**: 開発プロセス中、計画の変更に柔軟に対応できる。

<!-- 
このスライドでは、マイグレーションを計画および実装する際に、逆向きのマイグレーションも準備することの重要性について解説しています。逆向きのマイグレーションを用意することで、開発チームは新たな変更をより自信を持って進めることができ、万が一の問題が発生した際にも素早く対応することが可能となります。このアプローチは、リスクを効果的に管理し、プロジェクトの安定性を保つ上で不可欠です。
-->
---

# Alembicコマンドとマイグレーションファイル

Alembicを使用してマイグレーションファイルを生成する際、`alembic revision -m "メッセージ"` コマンドを使用します。このコマンドは、`upgrade()`と`downgrade()`関数を含む新しいマイグレーションファイルをスケルトンとして生成します。

## 自動生成される内容
自動生成されるマイグレーションファイルには、空の`upgrade()`と`downgrade()`関数が含まれます。開発者は、`upgrade()`関数にスキーマ変更を適用するコードを、`downgrade()`関数にその変更をロールバックするコードを記述する必要があります。

---

## カラム追加のパターン
### `upgrade()`の例
```python
def upgrade():
    op.add_column('user', sa.Column('new_column', sa.String(), nullable=True))
```

### `downgrade()`の例
```python
def downgrade():
    op.drop_column('user', 'new_column')
```

<!--
このスライドでは、Alembicを使用したマイグレーションファイルの生成方法と、自動生成される内容、そして`upgrade()`と`downgrade()`関数の具体的な記述例について解説しています。特に、カラムを追加するマイグレーションを例に、`downgrade()`関数に記述すべき内容とその重要性を強調しています。このプロセスを通じて、マイグレーションの柔軟性と安全性を保証することができます。
-->

---

# アンチパターンの例

- 大規模な一括更新
- データの不整合
- 直接本番データベースを変更する
- 適切なバックアップ計画の欠如
- 過度に複雑なマイグレーション

---

# アンチパターンの例 - 大規模な一括更新

大規模なデータベース更新を一度に行うことは、パフォーマンスの低下や長時間のダウンタイムを引き起こす可能性がある。このアプローチは、特にユーザーにとってのサービス利用に直接影響を与える場合、避けるべきである。

## 回避策
- **変更を小さな単位に分割する**: 更新を小さなマイグレーションに分割し、段階的に適用する。
- **バッチ処理の利用**: データ更新をバッチ処理で行い、一度に処理するデータの量を制限する。
- **非ピーク時間の利用**: ユーザーの活動が少ない時間帯を選んで更新作業を行う。

<!-- 
このスライドでは、データベースの大規模な一括更新が引き起こすリスクと、それを回避するための戦略について解説しています。大規模な更新を一度に行う代わりに、更新作業をより小さなタスクに分割し、バッチ処理を活用することで、システムの安定性を保ちながら必要なデータ更新を行うことが可能です。また、更新作業を非ピーク時間に計画することで、ユーザーへの影響を最小限に抑えることができます。
-->

---

# アンチパターンの例 - データの不整合

マイグレーション時にデータベース内でデータの不整合が発生すると、アプリケーションの予期せぬ挙動やデータ損失の原因となることがある。データの不整合は、マイグレーション中に適切な依存関係が考慮されていない場合や、マイグレーションが完全に適用されなかった場合に発生する。

## 回避策
- **事前の依存関係の検証**: マイグレーションを適用する前に、テーブル間の依存関係を慎重に検証する。
- **トランザクションの利用**: マイグレーションをトランザクション内で実行し、問題が発生した場合にはロールバックを行う。
- **厳格なテスト**: マイグレーションの前後で厳格なデータ整合性テストを実施する。

<!--
このスライドでは、マイグレーションプロセス中にデータの不整合が発生するリスクと、その問題を回避するための実践的な戦略について解説しています。特に、データベースの依存関係を正確に理解し、マイグレーション作業を慎重に計画すること、そして全体のプロセスをトランザクションで管理することが、データの一貫性を保つ上で重要です。また、テストを通じてマイグレーションの影響を詳細に検証することで、不整合のリスクを最小限に抑えることができます。
-->

---

# アンチパターンの例 - 直接本番データベースを変更する

テストやステージング環境を経由せずに、直接本番データベースに変更を加える行為は、重大なリスクを伴う。このアプローチは、データ損失やサービス中断、セキュリティの脆弱性を引き起こす可能性がある。

## 回避策
- **開発環境での変更のテスト**: 変更を本番環境に適用する前に、開発環境で十分にテストする。
- **ステージング環境での検証**: 本番環境と同様の条件下でステージング環境にて変更を検証する。
- **自動化されたデプロイメントプロセスの採用**: ヒューマンエラーを減らし、一貫性を保つために、自動化ツールを使用してデプロイメントプロセスを管理する。

<!--
このスライドでは、直接本番データベースを変更することのリスクと、そのリスクを回避するための方法について解説しています。開発環境とステージング環境での徹底的なテストと検証を行い、自動化ツールを利用することで、本番環境での変更をより安全に行うことが可能です。このプロセスを通じて、リスクを最小限に抑えつつ、品質を確保することができます。
-->

---

# アンチパターンの例 - 適切なバックアップ計画の欠如

マイグレーションやその他のデータベース変更を行う前に、完全なバックアップが取られていない場合、予期せぬ問題が発生した際にデータを復旧できない可能性がある。これは、データ損失やビジネスに対する深刻な影響を引き起こすリスクを伴う。

## 回避策
- **定期的なバックアップの実施**: データの定期的なバックアップを計画し、実施する。
- **マイグレーション前のバックアップ**: 重要な変更を行う前には、必ずその時点でのデータベースのバックアップを取る。
- **バックアップの検証**: バックアップが正常に行われ、必要に応じてデータの復旧が可能であることを確認する。

<!--
このスライドでは、適切なバックアップ計画の欠如がマイグレーションプロセスにおいてもたらすリスクと、そのリスクを避けるための実践的なアドバイスについて解説しています。定期的なバックアップの実施と、特に重要な変更前のバックアップ取得は、データの安全性を保つ上で不可欠です。また、バックアップが正しく行われているかの検証を怠らないことで、万が一の時に備えることができます。
-->

---

# アンチパターンの例 - 過度に複雑なマイグレーション

一度に多くの変更を含む複雑なマイグレーションは、問題の特定と修正を困難にし、ロールバックを複雑化させる。これにより、マイグレーションの適用が遅れたり、失敗のリスクが高まったりする可能性がある。

## 回避策
- **変更を小さな単位に分割する**: マイグレーションをより小さく、管理しやすい単位に分割して段階的に適用する。
- **詳細な計画の作成**: マイグレーションの各ステップを事前に計画し、依存関係や実行順序を明確にする。
- **充分なテスト**: 分割したマイグレーションごとに充分なテストを行い、問題が発生した場合にはその単位で対処する。

<!--
このスライドでは、マイグレーションプロセスにおいて過度に複雑なマイグレーションが及ぼす影響と、その問題を避けるための具体的な戦略について解説しています。マイグレーションを小さな単位に分割し、各ステップにおける詳細な計画とテストを行うことで、プロセス全体の管理が容易になり、リスクを軽減することができます。このアプローチにより、マイグレーションの成功率を高めることが可能です。
-->

---

# Q&A
## 質疑応答のセッション

---
layout: end

---

