---
theme: seriph
background: https://source.unsplash.com/collection/94734566/1920x1080
class: text-center
highlighter: shiki
info: |
  ## 2024-04-16_db_migration_with_alembic
  Presentation slides for 2024-04-16_db_migration_with_alembic.
transition: slide-left
title: 2024-04-16_db_migration_with_alembic
mdc: true
githubPages:
  ogp: true

---

# alembic によるデータベース管理とMigration

<!-- このページでは、Alembicを使ったデータベース管理とマイグレーションの概要を紹介します。Alembicとは何か、そしてなぜデータベース管理に有効なのかを説明し、その基本的な概念を明らかにします。具体的な使用例を挙げながら、このツールの強力な機能を示すことが目的です。 -->

---

# 講義のアジェンダ

- FastAPIでのデータベース操作
- マイグレーションのベストプラクティス
- マイグレーション戦略
- アンチパターンの例
- アンチパターンの回避
- Q&A

---

# FastAPIでのデータベース操作

- SQLAlchemyの紹介
- ORMとは何か？

<!-- このセクションでは、FastAPIを用いたデータベース操作に焦点を当て、特にSQLAlchemyとORM（Object Relational Mapping）について詳しく説明します。SQLAlchemyはPythonで最も広く使われているデータベースツールキットの一つで、データベースとのやり取りを抽象化し、Pythonオブジェクトを通じてデータベース操作を可能にします。ORMについては、それがどのようにしてデータベースのテーブルとPythonのクラスをマッピングするのか、そしてそれがなぜ開発者にとって便利なのかを解説します。FastAPIとこれらのツールを組み合わせることで、効率的かつ強力なウェブアプリケーションを構築することができます。具体的なコード例を交えて、これらの概念を実践的に理解していただくことを目指します。 -->

---

# SQLAlchemyの概要

SQLAlchemyは、PythonのORM（Object-Relational Mapping）フレームワークである。データベースとオブジェクト指向プログラミング言語間の橋渡しを行い、SQLクエリの代わりにPythonコードを使ってデータベース操作を可能にする。

<!-- このスライドでは、SQLAlchemyが何であり、なぜ多くのPython開発者に選ばれているのかについて解説します。ORMの概念と、SQLAlchemyが提供する抽象化レイヤがどのように開発の効率を向上させるかを説明します。 -->

---

# SQLAlchemyの基本的な使用方法

SQLAlchemyを使用すると、データベーステーブルはPythonクラスとして定義され、レコードはそのクラスのインスタンスとして表される。これにより、データベース操作をオブジェクト指向のアプローチで行えるようになる。

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

engine = create_engine('sqlite:///example.db')
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

new_user = User(name='John Doe')
session.add(new_user)
session.commit()
```

<!-- このスライドでは、SQLAlchemyを使った簡単なデータベース操作の例を示します。テーブルの定義からレコードの追加までのプロセスを通じて、SQLAlchemyの基本的な使用方法を解説します。 -->

---

# SQLAlchemyの高度な機能

SQLAlchemyは、リレーションシップの定義、複雑なクエリの構築、継承を用いたデータモデルの拡張といった高度なデータモデリング機能を提供する。これらの機能により、開発者は複雑なビジネスロジックを簡潔にコード化でき、大規模なアプリケーション開発においても柔軟性と効率性を実現できる。

---

## リレーションシップの定義

リレーションシップを定義することで、テーブル間の関連を表現し、オブジェクト間の関係性をコード上で直感的に扱うことが可能となる。この機能は、複数のテーブルにまたがるデータの取り扱いを簡素化し、データ整合性を保ちながら効率的な開発を支援する。


```python
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'))

    user = relationship("User", back_populates="addresses")

User.addresses = relationship("Address", order_by=Address.id, back_populates="user")
```
<!-- このスライドでは、SQLAlchemyの高度な機能に焦点を当てます。リレーションシップの管理を用いたデータモデルの拡張が、複雑なデータ構造を効果的に扱うための強力なツールであることを解説します。これらの機能を活用することで、よりリッチなデータ表現が可能になり、開発プロセスが効率化されます。 -->

---

## 継承の利用

SQLAlchemyでは、継承を利用して、共通の属性を持つモデル間でコードの重複を避けることができる。これにより、異なるテーブルを持つが関連するエンティティをモデル化する際に、基底クラスを定義し、その派生クラスとして具体的なサブクラスを作成することが可能となる。継承の利用は、データモデルの拡張性とメンテナンス性を向上させる。


```python
class Employee(User):
    __tablename__ = 'employees'
    id = Column(Integer, ForeignKey('users.id'), primary_key=True)
    hire_date = Column(Date)

    __mapper_args__ = {
        'polymorphic_identity':'employee',
    }

```

<!-- このスライドでは、SQLAlchemyの高度な機能に焦点を当てます。継承を用いたデータモデルの拡張が、複雑なデータ構造を効果的に扱うための強力なツールであることを解説します。これらの機能を活用することで、よりリッチなデータ表現が可能になり、開発プロセスが効率化されます。 -->

---

# ORMの基本概念

ORM（Object-Relational Mapping）は、リレーショナルデータベースのテーブルとオブジェクト指向プログラミング言語のクラスとの間のマッピングを実現する技術である。この技術により、開発者はデータベースを直接操作するSQLを書くことなく、プログラミング言語のクラスを使用してデータベースの操作が可能になる。

<!-- ORMの導入により、開発者はデータベース操作をより直感的に行えるようになります。このスライドでは、ORMの概念とその利点について説明します。特に、データモデルをコードとして表現することの重要性と、開発プロセスにおける効率化に焦点を当てます。 -->

---

# ORMの利点と課題

ORMは、プログラミングの抽象化レベルを高め、データベース操作の効率化を実現する。具体的な利点としては、開発速度の向上、コードの再利用性の向上、データベース設計とビジネスロジックの分離が挙げられる。一方で、パフォーマンスのオーバーヘッドや複雑なクエリの難易度上昇など、課題も存在する。

<!-- ORMを使用することで得られる主な利点と、遭遇する可能性のある課題について解説します。特に、ORMを適切に活用することで、これらの課題をどのように克服できるかについても触れます。このスライドを通じて、ORMの採用を検討する際の考慮点を提供します。 -->

---

# データベース操作ORM使用 - サンプル
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    email = Column(String)

Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

new_user = User(name='John Doe', email='john.doe@example.com')
session.add(new_user)
session.commit()

user = session.query(User).filter_by(name='John Doe').first()
print(f'Added user: {user.name}, Email: {user.email}')

```
<!-- 
このコードサンプルでは、SQLAlchemyというORMライブラリを使用しています。
ORMを使用する主な利点は、データベース操作をオブジェクト指向のアプローチで行えることです。

この例では、まずデータベースへの接続を設定し、次にユーザーモデルを定義しています。このモデルは、データベースのテーブルに対応しており、
テーブルの各行はこのクラスのインスタンスとして扱われます。SQLAlchemyを使うことで、
SQLクエリを直接書くことなくデータベーステーブルの作成、データの追加、データのクエリなどが可能になります。

特に、新しいユーザーの追加はPythonのオブジェクトを作成してセッションに追加するだけで完了し、
コミットすることでデータベースに反映されます。最後に、追加したユーザーをクエリしてその情報を表示しています。

このアプローチにより、データベース操作の抽象化レベルが高まり、
開発者はデータモデルとビジネスロジックに集中できるようになります。
-->

---

# データベース操作ORM未使用 - サンプル
```python
import sqlite3

conn = sqlite3.connect('example.db')
c = conn.cursor()

c.execute('''
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    email TEXT
)
''')

c.execute('INSERT INTO users (name, email) VALUES (?, ?)', ('John Doe', 'john.doe@example.com'))

conn.commit()

c.execute('SELECT * FROM users WHERE name=?', ('John Doe',))
user = c.fetchone()
print(f'Added user: {user[1]}, Email: {user[2]}')

conn.close()

```
<!-- 
このコードサンプルでは、Python標準のsqlite3ライブラリを使用して、ORMなしでデータベース操作を行っています。
ORMを使用しない場合、データベース操作には直接SQLクエリを書く必要があります。

この例では、まずデータベースへの接続を開き、ユーザーテーブルが存在しない場合は作成します。
次に、新しいユーザーをINSERTクエリを使用してテーブルに追加し、コミットして変更を保存しています。

ユーザーの追加後、SELECTクエリを使って追加したユーザーの情報をクエリし、表示しています。
最後に、使用が完了したデータベース接続を閉じています。

ORMを使用しないこの方法では、データベースとのやり取りを細かくコントロールできる一方で、
SQLクエリの記述によるエラーのリスクや、SQLインジェクションといったセキュリティリスクを自分で管理する必要があります。
また、コードの可読性や保守性にも影響を与える可能性があります。
-->
---

# マイグレーションのベストプラクティス

- 分割してマイグレーションを行う
- 本番環境への適用前のテスト
- バージョン管理の活用
- 逆向きのマイグレーションの作成


---

# 分割してマイグレーションを行う

大きな変更を一度に適用するのではなく、可能な限り小さな単位に分割してマイグレーションを行います。このアプローチにより、各変更の影響範囲が限定され、問題が発生した際の特定と修正が容易になります。

<!-- 分割してマイグレーションを行うことのメリットには、変更の管理がしやすくなること、問題発生時に迅速に対応できることなどがあります。このアプローチは、特に大きなプロジェクトや複数人での開発において有効です。 -->

---

## 分割してマイグレーションを行う - サンプル(テーブルの追加)

```python
"""Add user table

Revision ID: 01
Revises:
Create Date: 2022-09-01 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '01'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.create_table('user',
    sa.Column('id', sa.Integer, primary_key=True),
    sa.Column('name', sa.String(50), nullable=False),
    sa.Column('email', sa.String(120), unique=True, nullable=False)
    )

def downgrade():
    op.drop_table('user')

```
<!-- 
このスライドでは、大きなデータベース変更を小さなステップに分割して実行する方法について説明します。示されたマイグレーションファイルは、新しい`user`テーブルを追加するためのものです。

マイグレーションをこのように分割する主な利点は、変更の適用と問題発生時の追跡が容易になることです。また、必要に応じて特定の変更だけを簡単にロールバックできる柔軟性も提供します。このアプローチは、開発プロセスの透明性を高め、チームメンバー間でのコミュニケーションを促進します。
-->

---

## マイグレーションを分割して行う - サンプル(カラムの追加)

```python
"""Add age column to user table

Revision ID: 02
Revises: 01
Create Date: 2022-09-02 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '02'
down_revision = '01'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('user', sa.Column('age', sa.Integer, nullable=True))

def downgrade():
    op.drop_column('user', 'age')

```

<!--
このスライドでは、既存のテーブルに新しいカラムを追加するマイグレーションのサンプルを示しています。分割してマイグレーションを行うアプローチの一環として、`user`テーブルに`age`カラムを追加する小さな変更を独立したマイグレーションとして実装しています。

マイグレーションをこのように細かく管理することで、変更の粒度を細かくし、開発プロセスをよりコントロールしやすくします。また、問題が発生した際に、影響を受ける部分だけを特定しやすくなり、迅速な対応が可能になります。

このアプローチは、大規模なデータベース更新作業をより安全かつ効率的に行うための重要な手法です。  
-->

---

## マイグレーションを分割して行う - サンプル(nullableの変更)

既存のカラムで`NULL`が許容されているが、これを許容しないように変更したい場合、直接カラムの`nullable`属性を変更するだけではマイグレーションが失敗します。これは、既存データに`NULL`値が存在する場合、制約違反が発生するためです。

### デフォルト値で既存の`NULL`データを更新

```python
from alembic import op
import sqlalchemy as sa

def upgrade():
    # userテーブルのemailカラムにNULLが存在する場合、デフォルト値で更新
    op.execute("UPDATE user SET email = 'default@example.com' WHERE email IS NULL")
    op.alter_column('user', 'email', existing_type=sa.String(length=120), nullable=False)

```

<!--
このスライドでは、`nullable`属性の変更時に既存データが`NULL`を含む場合の対処法について説明しています。まず、対象カラムの既存の`NULL`データを適切なデフォルト値で更新し、その後でカラムの`nullable`属性を`False`に変更します。このプロセスを通じて、マイグレーションの際のエラーを避けることができます。
-->

---

# 本番環境への適用前のテスト

本番環境にマイグレーションを適用する前に、徹底的なテストを行うことは非常に重要です。これには、開発環境やステージング環境でのテストが含まれ、予期しないエラーやデータ損失を防ぐために必要なステップです。

## テストプロセス

1. **開発環境でのテスト**: 新しいマイグレーションが予定通りに機能するかを検証します。
2. **ステージング環境でのテスト**: 本番環境に近い条件でマイグレーションを実行し、さらに詳細なテストを行います。
3. **データ整合性の確認**: マイグレーション後のデータが正しく、完全であることを確認します。
4. **パフォーマンステスト**: マイグレーションがシステムのパフォーマンスに与える影響を評価します。

<!-- 
このスライドでは、本番環境への適用前に必要なテストプロセスについて説明しています。開発環境とステージング環境での徹底的なテストを通じて、本番環境でのマイグレーションがスムーズに行われるように準備します。特に、ステージング環境でのテストは本番環境と同様の条件を再現することで、リスクを最小限に抑えることができます。
-->

---

## 開発環境でのテスト
- マイグレーションの適用:   
開発環境に新しいマイグレーションを適用し、エラーが発生しないことを確認する。  
- 機能テスト:  
アプリケーションの関連機能がマイグレーション後も正常に動作するかテストする。  
例えば、新しいテーブルにデータが挿入できるか、既存のデータに対して期待通りのクエリが実行できるかなど。  

---

## ステージング環境でのテスト
- 本番環境との条件整合:  
ステージング環境で本番環境に近いデータと設定を用いてマイグレーションを適用し、予期しない挙動がないか確認する。  
- ロードテストとパフォーマンス評価:  
大量のデータやリクエストを処理する際のパフォーマンスをテストし、マイグレーションがシステムのパフォーマンスに悪影響を及ぼさないことを確認する。  
- セキュリティチェック:  
マイグレーションによって新たに導入された変更がセキュリティ上の脆弱性を生じさせていないか検証する。  

---

## データ整合性の確認
- データ検証:  
マイグレーション後のデータが完全であり、かつ整合性が保たれていることを確認する。  
これには、マイグレーション前後でのデータの照合、予期せぬデータ損失がないかのチェックが含まれる。  
- バックアップとリカバリプロセスの確認:  
データのバックアップが正しく行われているか、そして必要に応じてリカバリが可能であることを確認する。  

<!-- 
このスライドでは、本番環境への適用前に必要なテストプロセスについて詳細に説明しています。開発環境での初期テストからスタートし、ステージング環境での包括的なテストを経て、データの整合性とシステムの安定性を最終確認します。この徹底的なテストを通じて、マイグレーションが予期せぬ問題を引き起こすリスクを最小限に抑えることができます。
-->

---

## パフォーマンステスト
本番環境への適用前のテストプロセスにおいて、パフォーマンステストは特に重要になる。  
このテストは、マイグレーション後のシステムが高いトラフィックや大量のデータを効率的に処理できることを確認するために実施される。  


## パフォーマンステストのステップ
- ロードテスト:  
システムが大量のリクエストを同時に処理できるかをテストする。
- ストレステスト:  
システムの限界を把握するため、通常の運用負荷を超えるリクエストを送信する。
- スケーラビリティテスト:  
システムが成長するデータ量やユーザー数に応じて適切にスケールアップできるかを確認する。

<!--
このスライドでは、本番環境にマイグレーションを適用する前に行うべきパフォーマンステストの重要性と、具体的なテスト手法について説明しています。マイグレーションがシステムのパフォーマンスに悪影響を及ぼさないようにするため、ロードテスト、ストレステスト、スケーラビリティテストを含む徹底的なパフォーマンス評価が必要です。これにより、本番環境でのユーザー体験が最適化されることを保証します。
-->

---

# バージョン管理の活用

マイグレーションプロセスにおけるバージョン管理システムの活用は、変更の追跡、共有及び協調作業を容易にし、マイグレーションの整合性を保つ。これにより、複数の開発者間の作業が効率化される。

## バージョン管理の利点
- **変更履歴の追跡**: どの変更がいつ、誰によって行われたかが明確になる。
- **差分の確認**: 異なるバージョン間の変更内容を簡単に確認できる。
- **ロールバックの容易化**: 問題が発生した場合、以前の安定した状態へ簡単に戻せる。

<!-- 
このスライドでは、マイグレーションにおけるバージョン管理システムの重要性と、それを活用することの利点について解説しています。バージョン管理を適切に活用することで、開発プロセスが透明になり、チームメンバー間のコミュニケーションが促進されます。特に、複数人での開発や大規模プロジェクトにおいて、バージョン管理の活用は非常に重要です。プロジェクトの進行状況を正確に追跡し、必要に応じて以前の安定したバージョンに戻すことができるため、リスクを最小限に抑えることができます。
-->

---

## バージョン管理で気を付けるべきこと

マイグレーションファイルの管理において、バージョン管理は変更の追跡、共有、及び協調作業を容易にする。特にマイグレーションファイルの命名規則や管理には以下のポイントに注意する必要がある。

<!--
マイグレーションファイルをバージョン管理する際には、一意性を保つ命名規則を設けること、変更内容が分かるようにすること、そして逆マイグレーションが可能であることが重要です。これらのポイントに注意を払うことで、マイグレーションプロセスがスムーズに進行し、開発チーム間でのコミュニケーションも促進されます。特に、大規模なプロジェクトや複数人での開発において、これらの実践はプロジェクトの成功に不可欠です。
-->

---

## マイグレーションファイルの命名規則
- **一意性を保つ**
- **日付やタイムスタンプを利用する**
- **変更内容を簡潔に記述する**

<!--
一意性を保つ: マイグレーションファイルの名前は、プロジェクト内で一意である必要があります。これにより、どのマイグレーションが適用されているか、または適用されていないかを容易に識別できます。  
日付やタイムスタンプを利用する: マイグレーションファイルの名前に日付やタイムスタンプを含めることで、マイグレーションが作成された順序を明確にできます。例えば、20210401_add_user_tableのようにします。  
変更内容を簡潔に記述する: ファイル名からマイグレーションの主な目的や変更内容がわかるようにすると、ファイルを探す時間が節約でき、理解もしやすくなります。  
-->

---

## マイグレーションファイルの管理
- **逆マイグレーションの準備**
- **詳細なコメントを追加する**

<!--
逆マイグレーションの準備: すべてのマイグレーションファイルには、変更をロールバックするための逆マイグレーションコードを含めるべきです。これにより、問題が発生した場合に以前の状態に戻せるようになります。  
詳細なコメントを追加する: マイグレーションファイル内には、変更の目的や背景、特定の変更が必要とされた理由についてのコメントを追加すると良いでしょう。これにより、他の開発者がマイグレーションの意図を理解しやすくなります。  
-->

---

## チーム内での共有とコミュニケーション
- **マイグレーション戦略を共有する**
- **マイグレーション適用の順序を確認する**

<!--
マイグレーション戦略を共有する: 新しいマイグレーションを追加する際は、チーム内でその内容と目的を共有し、フィードバックを受けることが重要です。これにより、予期しない問題を未然に防げる場合があります。  
マイグレーション適用の順序を確認する: 複数の開発者が異なるマイグレーションを同時に進めている場合、それらが互いに依存しないように注意し、適用の順序を正しく管理する必要があります。  
-->

---

# 逆向きのマイグレーションの作成

マイグレーションを実装する際には、進行方向だけでなく、必要に応じて変更を元に戻せるように、逆向きのマイグレーションも準備することが重要である。これにより、新たなマイグレーションが予期せぬ問題を引き起こした場合でも、システムを安定した状態に戻すことができる。

## 逆向きマイグレーションの利点
- **安全性の向上**: 新しい変更による問題からシステムを守り、迅速に元の状態に戻すことができる。
- **リスク管理**: マイグレーションによる影響をテストしやすくなり、本番環境でのリスクを最小限に抑えることができる。
- **柔軟性**: 開発プロセス中、計画の変更に柔軟に対応できる。

<!-- 
このスライドでは、マイグレーションを計画および実装する際に、逆向きのマイグレーションも準備することの重要性について解説しています。逆向きのマイグレーションを用意することで、開発チームは新たな変更をより自信を持って進めることができ、万が一の問題が発生した際にも素早く対応することが可能となります。このアプローチは、リスクを効果的に管理し、プロジェクトの安定性を保つ上で不可欠です。
-->
---

# Alembicコマンドとマイグレーションファイル

Alembicを使用してマイグレーションファイルを生成する際、`alembic revision -m "メッセージ"` コマンドを使用します。このコマンドは、`upgrade()`と`downgrade()`関数を含む新しいマイグレーションファイルをスケルトンとして生成します。

## 自動生成される内容
自動生成されるマイグレーションファイルには、空の`upgrade()`と`downgrade()`関数が含まれます。開発者は、`upgrade()`関数にスキーマ変更を適用するコードを、`downgrade()`関数にその変更をロールバックするコードを記述する必要があります。

---

## カラム追加のパターン
### `upgrade()`の例
```python
def upgrade():
    op.add_column('user', sa.Column('new_column', sa.String(), nullable=True))
```

### `downgrade()`の例
```python
def downgrade():
    op.drop_column('user', 'new_column')
```

<!--
このスライドでは、Alembicを使用したマイグレーションファイルの生成方法と、自動生成される内容、そして`upgrade()`と`downgrade()`関数の具体的な記述例について解説しています。特に、カラムを追加するマイグレーションを例に、`downgrade()`関数に記述すべき内容とその重要性を強調しています。このプロセスを通じて、マイグレーションの柔軟性と安全性を保証することができます。
-->
---

# マイグレーション戦略

- 段階的な適用
- マイグレーションのテスト方法

<!-- このスライドでは、マイグレーションプロセスを計画し、段階的に適用するための戦略に焦点を当てます。マイグレーション戦略の策定は、データベースの変更を効率的かつ安全に管理するために不可欠です。計画段階では、変更の範囲、影響を受けるシステム、必要なリソースを明確に定義します。段階的な適用は、大規模な変更を小さな部分に分割し、一つずつ適用することで、リスクを最小限に抑えることができます。また、マイグレーションの各段階でのテストは、変更が期待通りに機能することを確認し、問題があれば早期に対処するために重要です。このセクションでは、マイグレーション戦略の重要性と、効果的な計画およびテスト方法について具体的なアドバイスを提供します。 -->

---


# アンチパターンの例

- 大規模な一括更新
- データの不整合

<!-- このスライドでは、マイグレーションプロセスにおける一般的なアンチパターンの例を挙げ、それらの問題点と回避方法について解説します。最初のアンチパターンは「大規模な一括更新」です。データベースの大部分を一度に更新しようとすると、パフォーマンスの低下やダウンタイムのリスクが高まります。これを避けるためには、変更を小さな部分に分割し、段階的に適用することが推奨されます。次に、「データの不整合」は、マイグレーション後にデータベース内の情報が一貫性を欠くことを指します。これは、変更の適用が不完全であったり、関連するテーブル間で更新が同期されていない場合に発生します。データの一貫性を保つためには、厳格なテストと、マイグレーションの前後でのデータ検証プロセスが必要です。このセクションでは、これらのアンチパターンを避けるための実践的なアドバイスを提供し、より効果的なマイグレーション戦略を構築するための指針を示します。 -->

---

# アンチパターンの回避

- 小さな変更の積み重ね
- コードレビューの活用

<!-- このスライドでは、マイグレーションプロセスにおけるアンチパターンを回避するための実践的なアプローチについて解説します。アンチパターンを避けるための最も効果的な方法の一つは、大規模な変更を避け、代わりに小さな変更を積み重ねていくことです。これにより、各変更の影響を容易に追跡し、問題が発生した場合に迅速に対応できます。また、コードレビューを積極的に活用することも重要です。コードレビューを通じて、他の開発者がマイグレーションのコードを事前に検証し、問題や潜在的な改善点を指摘できます。これは、品質を保証し、共通の理解を促進するために非常に価値があります。このセクションでは、これらのアプローチを具体的にどのように実施するか、実践的なガイドラインを提供します。 -->

---

# Q&A
## 質疑応答のセッション

---
layout: end

---

